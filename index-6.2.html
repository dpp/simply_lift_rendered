<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>    <title>      Simply Lift    </title>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />    <!-- scripts for highlighter -->    <script type="text/javascript" src="scripts/shCore.js"></script>    <script type="text/javascript" src="scripts/shBrushXml.js"></script>    <script type="text/javascript" src="scripts/shBrushScala.js"></script>    <script type="text/javascript" src="scripts/shBrushBash.js"></script>    <!-- CSS for highlighter -->    <link href="css/shCore.css" rel="stylesheet" type="text/css" />    <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />    <link rel="stylesheet" href="css/lyx.css" type="text/css" media="screen"/>  </head>  <body>    <div id="globalWrapper">      <div class="splitheader">
<span class="prev"><a class="prev" name="prev" href="index-6.1.html#Next">Previous: Section 6.1</a></span>
<span class="up"><a class="up" href="index-Chapter-6.html">Up: Chapter 6</a></span>
<span class="next"><a class="next" name="Next" href="index-6.3.html#prev">Next: Section 6.3</a></span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.2">6.2</a> Hooking it up to the UI
</h2>
<div class="Standard">
Now that we can declare relationships among cells, how do we associate the value of <tt>Cell</tt>s with the user interface?
</div>
<div class="Standard">
Turns out that it’s pretty simple:
</div>
<div class="Standard">
<div class="listing">
<pre class="listing brush: scala"> "#total" #&gt; WiringUI.asText(total)
</pre>
</div>

</div>
<div class="Standard">
We associate the element with <tt>id="total"</tt> with a function that displays the value in <tt>total</tt>. Here’s the method definition:
</div>
<div class="Standard">
<div class="listing">
<pre class="listing brush: scala">  /**
   * Given a Cell register the
   * postPageJavaScript that will update the element with
   * a new value.
   *
   * @param cell the cell to associate with
   * 
   * @return a function that will mutate the NodeSeq (an id attribute may be added if
   * there’s none already defined)
   */
  def asText[T](cell: Cell[T]): NodeSeq =&gt; NodeSeq = 
</pre>
</div>

</div>
<div class="Standard">
Huh? that’s a lot of mumbo-jumbo... what’s a <tt>postPageJavaScript</tt>?
</div>
<div class="Standard">
So, here’s the magic of <tt>WiringUI</tt>: Most web frameworks treat a page rendering as an event in time. Maybe (in the case of Seaside), there are some side effects of rendering that close over page rendering state such that when forms are submitted back, you get page state back. Lift treats a full HTML page render and subsequent Ajax requests on the page as a single event that has a single scope. This means that <tt>RequestVar</tt>s populated during a page render are available during subsequent Ajax requests on that page. Part of the state that results in a page render is the <tt>postPageJavaScript</tt> which is a bucket of <tt>() =&gt; JsCmd</tt> or a collection of functions that return JavaScript. Before responding to any HTTP request associated with the page, Lift runs all these functions and appends the resulting JavaScript to the response sent back to the browser. HTTP requests associated with the page include the initial page render, subsequent Ajax request associated with the page and associated Comet (long poll) requests generated by the page.
</div>
<div class="Standard">
For each <tt>Cell</tt> that you wire up to the user interface, Lift captures the id of the DOM node (and if there’s no id, Lift will assign one) and the current value of the <tt>Cell</tt>. Lift generates a function that looks at the current <tt>Cell</tt> value and if it’s changed, Lift generates JavaScript that updates the DOM node with the <tt>Cell</tt>’s current value.
</div>
<div class="Standard">
The result is that if an Ajax operation changes the value of a <tt>ValueCell</tt>, then all the dependent cells will update and the associated DOM updates will be carried back with the HTTP response.
</div>
<div class="Standard">
You have a lot of control over the display of the value. The <tt>asText</tt> method creates a <tt>Text(cell.toString)</tt>. However, <tt>WiringUI.apply</tt> allows you to associate a function that converts the <tt>Cell</tt>’s type <tt>T</tt> to a <tt>NodeSeq</tt>. Further, you can control the transition in the browser with a <tt>jsEffect</tt> (type signiture <tt>(String, Boolean, JsCmd) =&gt; JsCmd</tt>). There are pre-build <tt>jsEffects</tt> based on jQuery including my favorite, <tt>fade</tt>:
</div>
<div class="Standard">
<div class="listing">
<pre class="listing brush: scala">  /**
   * Fade out the old value and fade in the new value
   * using jQuery fast fade.
   */
  def fade: (String, Boolean, JsCmd) =&gt; JsCmd = {
    (id: String, first: Boolean, cmd: JsCmd) =&gt; {
      if (first) cmd
      else {
        val sel = "jQuery(’#’+"+id.encJs+")"
        Run(sel+".fadeOut(’fast’, function() {"+
            cmd.toJsCmd+" "+sel+".fadeIn(’fast’);})")
      }
    }
  }
</pre>
</div>

</div>
<div class="Standard">
Which you can use as: 
</div>
<div class="Standard">
<div class="listing">
<pre class="listing brush: scala"> "#total" #&gt; WiringUI.asText(total, JqWiringSupport.fade)
</pre>
</div>

</div>
<div class="Standard">
Now, when the total field updates, the old value will fade out and the new value will fade in... cool.
</div>
<div class="splitheader">
<span class="prev"><a class="prev" name="prev" href="index-6.1.html#Next">Previous: Section 6.1</a></span>
<span class="up"><a class="up" href="index-Chapter-6.html">Up: Chapter 6</a></span>
<span class="next"><a class="next" name="Next" href="index-6.3.html#prev">Next: Section 6.3</a></span>
</div>
          <p class="bottom">(C) 2012 David Pollak</p>    </div>    <script type="text/javascript">SyntaxHighlighter.all()</script>  </body></html>